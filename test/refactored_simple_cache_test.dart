// Copyright (C) 2025 Intel Corporation
// SPDX-License-Identifier: BSD-3-Clause
//
// refactored_simple_cache_test.dart
// Tests for the refactored cache controller using Interface classes.
//
// 2025 January 10
// Author: Generated by Copilot

import 'dart:async';

import 'package:rohd/rohd.dart';
import 'package:rohd_hcl/src/memory/cache_controller_interfaces.dart';
import 'package:rohd_hcl/src/memory/refactored_simple_cache.dart';
import 'package:test/test.dart';

void main() {
  tearDown(() async {
    await Simulator.reset();
  });

  group('RefactoredSimpleCache', () {
    test('should construct without errors', () async {
      final clk = SimpleClockGenerator(10).clk;
      final reset = Logic();

      final upstreamReqIntf = CacheRequestInterface(4, 32);
      final upstreamRespIntf = CacheResponseInterface(4, 32, 64);
      final downstreamReqIntf = CacheRequestInterface(4, 32);
      final downstreamRespIntf = CacheResponseInterface(4, 32, 64);

      final cacheController = RefactoredSimpleCache(
        clk,
        reset,
        upstreamReqIntf,
        upstreamRespIntf,
        downstreamReqIntf,
        downstreamRespIntf,
      );

      await cacheController.build();

      expect(cacheController.upstreamReq.idWidth, equals(4));
      expect(cacheController.upstreamReq.addrWidth, equals(32));
      expect(cacheController.upstreamResp.dataWidth, equals(64));
    });

    test('should generate SystemVerilog', () async {
      final clk = SimpleClockGenerator(10).clk;
      final reset = Logic();

      final upstreamReqIntf = CacheRequestInterface(4, 16);
      final upstreamRespIntf = CacheResponseInterface(4, 16, 32);
      final downstreamReqIntf = CacheRequestInterface(4, 16);
      final downstreamRespIntf = CacheResponseInterface(4, 16, 32);

      final cacheController = RefactoredSimpleCache(
        clk,
        reset,
        upstreamReqIntf,
        upstreamRespIntf,
        downstreamReqIntf,
        downstreamRespIntf,
        cacheLines: 8,
        name: 'test_refactored_cache',
      );

      await cacheController.build();

      final sv = cacheController.generateSynth();
      expect(sv, contains('module RefactoredSimpleCache'));
      expect(sv, contains('upstream_req_id'));
      expect(sv, contains('upstream_resp_data'));
      expect(sv, contains('downstream_req_addr'));
      expect(sv, contains('downstream_resp_valid'));
    });

    test('should handle basic request flow', () async {
      final clk = SimpleClockGenerator(10).clk;
      final reset = Logic();

      const idWidth = 3;
      const addrWidth = 8;
      const dataWidth = 16;

      final upstreamReqIntf = CacheRequestInterface(idWidth, addrWidth);
      final upstreamRespIntf =
          CacheResponseInterface(idWidth, addrWidth, dataWidth);
      final downstreamReqIntf = CacheRequestInterface(idWidth, addrWidth);
      final downstreamRespIntf =
          CacheResponseInterface(idWidth, addrWidth, dataWidth);

      final cacheController = RefactoredSimpleCache(
        clk,
        reset,
        upstreamReqIntf,
        upstreamRespIntf,
        downstreamReqIntf,
        downstreamRespIntf,
        cacheLines: 4,
      );

      await cacheController.build();
      WaveDumper(cacheController, outputPath: 'refactored_cache.vcd');

      // Create test bench signals
      final upstreamReqId = Logic(width: 3);
      final upstreamReqAddr = Logic(width: 8);
      final upstreamReqValid = Logic();
      final upstreamRespReady = Logic();
      final downstreamRespId = Logic(width: 3);
      final downstreamRespAddr = Logic(width: 8);
      final downstreamRespData = Logic(width: 16);
      final downstreamRespValid = Logic();
      final downstreamReqReady = Logic();

      // Connect test signals to the external interfaces that were passed to the
      // constructor The connectIO method in the module handles the internal
      // connections

      // Upstream request signals (driven by testbench into module)
      upstreamReqIntf.id <= upstreamReqId;
      upstreamReqIntf.addr <= upstreamReqAddr;
      upstreamReqIntf.valid <= upstreamReqValid;

      // Upstream response ready (driven by testbench)
      upstreamRespIntf.ready <= upstreamRespReady;

      // Downstream response signals (driven by testbench into module)
      downstreamRespIntf.id <= downstreamRespId;
      downstreamRespIntf.addr <= downstreamRespAddr;
      downstreamRespIntf.data <= downstreamRespData;
      downstreamRespIntf.valid <= downstreamRespValid;

      // Downstream request ready (driven by testbench)
      downstreamReqIntf.ready <= downstreamReqReady;

      // Initialize downstream response to inactive
      downstreamRespValid.put(0);

      // Start simulation
      Simulator.setMaxSimTime(1000);
      WaveDumper(cacheController, outputPath: 'cc.vcd');
      unawaited(Simulator.run());

      // Reset
      reset.inject(0);
      await clk.nextNegedge;
      reset.inject(1);
      await clk.nextNegedge;
      reset.inject(0);
      await clk.nextNegedge;

      // Test basic request (should be cache miss initially)
      upstreamReqId.put(4);
      upstreamReqAddr.put(0x01); // Address that maps to cache line 0
      upstreamReqValid.put(1);
      upstreamRespReady.put(1);
      downstreamReqReady.put(1);

      await clk.nextPosedge;
      await clk.nextPosedge; // Extra cycle for signal propagation

      // Should forward to downstream (cache miss)
      expect(downstreamReqIntf.valid.value.toInt(), equals(1));
      expect(downstreamReqIntf.id.value.toInt(), equals(4));
      expect(downstreamReqIntf.addr.value.toInt(), equals(0x01));

      // Oracle responds: data = address (as specified in the oracle pattern)
      downstreamRespId.put(downstreamReqIntf.id.value.toInt());
      downstreamRespAddr.put(downstreamReqIntf.addr.value.toInt());
      downstreamRespData
          .put(downstreamReqIntf.addr.value.toInt()); // Oracle: data = address
      downstreamRespValid.put(1);

      await clk.nextPosedge;
      await clk.nextPosedge;

      // Clear upstream request and test cache hit
      upstreamReqValid.put(0);
      await clk.nextPosedge;

      upstreamReqId.put(2);
      upstreamReqAddr.put(0x01); // Same address - should be cache hit
      upstreamReqValid.put(1);

      await clk.nextPosedge;
      await clk.nextPosedge; // Extra cycle for MultiPortedReadCache processing

      // Should be cache hit now - no downstream request
      if (upstreamRespIntf.valid.value.isValid) {
        expect(downstreamReqIntf.valid.value.toInt(), equals(0));
        expect(upstreamRespIntf.valid.value.toInt(), equals(1));
        expect(upstreamRespIntf.data.value.toInt(),
            equals(0x01)); // Cached oracle data (address)
      }

      await Simulator.endSimulation();
    });

    test('should validate constructor parameters', () {
      final clk = SimpleClockGenerator(10).clk;
      final reset = Logic();

      final upstreamReqIntf = CacheRequestInterface(4, 16);
      final upstreamRespIntf = CacheResponseInterface(4, 16, 32);
      final downstreamReqIntf = CacheRequestInterface(4, 16);
      final downstreamRespIntf = CacheResponseInterface(4, 16, 32);

      // Test invalid cache lines (not power of 2)
      expect(
        () => RefactoredSimpleCache(
          clk,
          reset,
          upstreamReqIntf,
          upstreamRespIntf,
          downstreamReqIntf,
          downstreamRespIntf,
          cacheLines: 15, // Not power of 2
        ),
        throwsArgumentError,
      );

      // Test zero cache lines
      expect(
        () => RefactoredSimpleCache(
          clk,
          reset,
          upstreamReqIntf,
          upstreamRespIntf,
          downstreamReqIntf,
          downstreamRespIntf,
          cacheLines: 0,
        ),
        throwsArgumentError,
      );
    });
  });
}
