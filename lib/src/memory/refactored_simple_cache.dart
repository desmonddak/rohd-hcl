// Copyright (C) 2025 Intel Corporation
// SPDX-License-Identifier: BSD-3-Clause
//
// refactored_simple_cache.dart
// A refactored version of SimpleCache using Interface classes.
//
// 2025 January 10
// Author: Generated by Copilot

import 'package:rohd/rohd.dart';
import 'package:rohd_hcl/rohd_hcl.dart';
import 'package:rohd_hcl/src/memory/cache_controller_interfaces.dart';

/// A refactored cache controller that uses Interface classes.
///
/// This component demonstrates refactoring the SimpleCache to use proper
/// interfaces:
/// 1. CacheRequestInterface for upstream/downstream requests
/// 2. CacheResponseInterface for upstream/downstream responses
/// 3. Uses the Cache constructor pattern for interface handling
class RefactoredSimpleCache extends Module {
  /// The width of data.
  final int dataWidth;

  /// The number of cache lines (must be power of 2).
  final int cacheLines;

  /// Upstream request interface (internal).
  late final CacheRequestInterface upstreamReq;

  /// Upstream response interface (internal).
  late final CacheResponseInterface upstreamResp;

  /// Downstream request interface (internal).
  late final CacheRequestInterface downstreamReq;

  /// Downstream response interface (internal).
  late final CacheResponseInterface downstreamResp;

  /// Response FIFO for queuing responses.
  late final Fifo responseFifo;

  /// Constructs a cache controller using the Cache constructor pattern.
  RefactoredSimpleCache(
    Logic clk,
    Logic reset,
    CacheRequestInterface upstreamReqInterface,
    CacheResponseInterface upstreamRespInterface,
    CacheRequestInterface downstreamReqInterface,
    CacheResponseInterface downstreamRespInterface, {
    this.cacheLines = 16,
    super.name = 'RefactoredSimpleCache',
    super.reserveName,
    super.reserveDefinitionName,
    String? definitionName,
  })  : dataWidth = upstreamRespInterface.dataWidth,
        super(
            definitionName: definitionName ??
                'RefactoredSimpleCache_ID${upstreamReqInterface.idWidth}'
                    '_A${upstreamReqInterface.addrWidth}'
                    '_D${upstreamRespInterface.dataWidth}_L$cacheLines') {
    // Validate parameters
    if (cacheLines <= 0 || (cacheLines & (cacheLines - 1)) != 0) {
      throw ArgumentError('cacheLines must be a positive power of 2');
    }

    // Create internal signals from external Logic parameters
    final internalClk = addInput('clk', clk);
    final internalReset = addInput('reset', reset);

    // Create internal interfaces by cloning external ones and connecting them
    // This follows the proper ROHD interface pattern from APB, AXI4, etc.
    upstreamReq = upstreamReqInterface.clone()
      ..connectIO(this, upstreamReqInterface,
          inputTags: {CacheControllerDirection.request},
          uniquify: (original) => 'upstream_req_$original');

    upstreamResp = upstreamRespInterface.clone()
      ..connectIO(this, upstreamRespInterface,
          outputTags: {CacheControllerDirection.response},
          uniquify: (original) => 'upstream_resp_$original');

    downstreamReq = downstreamReqInterface.clone()
      ..connectIO(this, downstreamReqInterface,
          outputTags: {CacheControllerDirection.request},
          uniquify: (original) => 'downstream_req_$original');

    downstreamResp = downstreamRespInterface.clone()
      ..connectIO(this, downstreamRespInterface,
          inputTags: {CacheControllerDirection.response},
          uniquify: (original) => 'downstream_resp_$original');

    _buildLogic(internalClk, internalReset);
  }

  /// Builds the internal logic for the cache controller.
  void _buildLogic(Logic clk, Logic reset) {
    // Get dimensions from interfaces
    final idWidth = upstreamReq.idWidth;
    final addrWidth = upstreamReq.addrWidth;
    final cacheAddrWidth = log2Ceil(cacheLines);

    // Create FIFO for response buffering
    final fifoWriteData =
        Logic(name: 'fifo_write_data', width: idWidth + addrWidth + dataWidth);
    final fifoWriteEnable = Logic(name: 'fifo_write_enable');
    final fifoReadEnable = Logic(name: 'fifo_read_enable');

    responseFifo = Fifo(
      clk,
      reset,
      writeEnable: fifoWriteEnable,
      writeData: fifoWriteData,
      readEnable: fifoReadEnable,
      depth: 8,
      name: 'response_fifo',
    );

    // Create simple cache storage (like SimpleCache does)
    final cacheData = List.generate(
      cacheLines,
      (i) => Logic(width: dataWidth, name: 'cache_data_$i'),
    );

    final cacheValid = List.generate(
      cacheLines,
      (i) => Logic(name: 'cache_valid_$i'),
    );

    // Initialize cache valid bits on reset and update on cache fill
    Sequential(clk, [
      If(reset, then: [
        for (int i = 0; i < cacheLines; i++) ...[
          cacheValid[i] < Const(0),
          cacheData[i] < Const(0, width: dataWidth),
        ],
      ], orElse: [
        // Update cache on downstream response
        If(downstreamResp.valid, then: [
          Case(downstreamResp.addr.slice(cacheAddrWidth - 1, 0), [
            for (int i = 0; i < cacheLines; i++)
              CaseItem(Const(i, width: cacheAddrWidth), [
                cacheData[i] < downstreamResp.data,
                cacheValid[i] < Const(1),
              ]),
          ]),
        ]),
      ]),
    ]);

    // Extract cache index from upstream address
    final upstreamCacheIdx = upstreamReq.addr.slice(cacheAddrWidth - 1, 0);

    // Simple cache hit logic - check if cache line is valid
    final cacheHit = Logic(name: 'cache_hit');
    final cacheHitData = Logic(width: dataWidth, name: 'cache_hit_data');

    // Cache lookup using combinational logic
    Combinational([
      If(reset, then: [
        // During reset, cache is always miss
        cacheHit < Const(0),
        cacheHitData < Const(0, width: dataWidth),
      ], orElse: [
        Case(upstreamCacheIdx, [
          for (int i = 0; i < cacheLines; i++)
            CaseItem(Const(i, width: cacheAddrWidth), [
              cacheHit < cacheValid[i],
              cacheHitData < cacheData[i],
            ]),
        ], defaultItem: [
          cacheHit < Const(0),
          cacheHitData < Const(0, width: dataWidth),
        ]),
      ]),
    ]);

    // Upstream request processing
    final upstreamReqFire = upstreamReq.valid;

    // Always ready to accept requests (simplified)
    upstreamReq.ready <= Const(1);

    // Response logic
    final responseFromCache = cacheHit & upstreamReqFire;
    final responseFromFifo = ~responseFifo.empty & upstreamResp.ready;

    // Connect upstream response
    upstreamResp.valid <= responseFromCache | responseFromFifo;
    upstreamResp.id <=
        mux(
            responseFromCache,
            upstreamReq.id,
            responseFifo.readData.slice(
                idWidth + addrWidth + dataWidth - 1, addrWidth + dataWidth));
    upstreamResp.addr <=
        mux(responseFromCache, upstreamReq.addr,
            responseFifo.readData.slice(addrWidth + dataWidth - 1, dataWidth));
    upstreamResp.data <=
        mux(responseFromCache, cacheHitData,
            responseFifo.readData.slice(dataWidth - 1, 0));

    // Forward cache misses to downstream
    final cacheMiss = ~cacheHit & upstreamReqFire;

    // Ensure downstream request is always driven (avoid 'x' values)
    downstreamReq.valid <= mux(reset, Const(0), cacheMiss);
    downstreamReq.id <= mux(reset, Const(0, width: idWidth), upstreamReq.id);
    downstreamReq.addr <=
        mux(reset, Const(0, width: addrWidth), upstreamReq.addr);

    // Always ready for downstream responses
    downstreamResp.ready <= Const(1);

    // Queue downstream responses in FIFO and update cache
    fifoWriteEnable <= downstreamResp.valid;
    fifoWriteData <=
        [downstreamResp.id, downstreamResp.addr, downstreamResp.data].swizzle();

    // FIFO read control
    fifoReadEnable <= responseFromFifo;

    // Connect cache fill interface to downstream responses
    // The Cache component handles internal storage automatically
  }
}
