// Copyright (C) 2025 Intel Corporation
// SPDX-License-Identifier: BSD-3-Clause
//
// refactored_simple_cache.dart
// A refactored version of SimpleCache using Interface classes.
//
// 2025 January 10
// Author: Generated by Copilot

import 'package:rohd/rohd.dart';
import 'package:rohd_hcl/rohd_hcl.dart';
import 'package:rohd_hcl/src/memory/cache_controller_interfaces.dart';

/// A refactored cache controller that uses Interface classes.
///
/// This component demonstrates refactoring the SimpleCache to use proper
/// interfaces:
/// 1. CacheRequestInterface for upstream/downstream requests
/// 2. CacheResponseInterface for upstream/downstream responses
/// 3. Uses the Cache constructor pattern for interface handling
class RefactoredSimpleCache extends Module {
  /// The width of data.
  final int dataWidth;

  /// The number of cache lines (must be power of 2).
  final int cacheLines;

  /// Upstream request interface (internal).
  late final CacheRequestInterface upstreamReq;

  /// Upstream response interface (internal).
  late final CacheResponseInterface upstreamResp;

  /// Downstream request interface (internal).
  late final CacheRequestInterface downstreamReq;

  /// Downstream response interface (internal).
  late final CacheResponseInterface downstreamResp;

  /// Response FIFO for queuing responses.
  late final Fifo responseFifo;

  /// Constructs a cache controller using the Cache constructor pattern.
  RefactoredSimpleCache(
    Logic clk,
    Logic reset,
    CacheRequestInterface upstreamReqInterface,
    CacheResponseInterface upstreamRespInterface,
    CacheRequestInterface downstreamReqInterface,
    CacheResponseInterface downstreamRespInterface, {
    this.cacheLines = 16,
    super.name = 'RefactoredSimpleCache',
    super.reserveName,
    super.reserveDefinitionName,
    String? definitionName,
  })  : dataWidth = upstreamRespInterface.dataWidth,
        super(
            definitionName: definitionName ??
                'RefactoredSimpleCache_ID${upstreamReqInterface.idWidth}'
                    '_A${upstreamReqInterface.addrWidth}'
                    '_D${upstreamRespInterface.dataWidth}_L$cacheLines') {
    // Validate parameters
    if (cacheLines <= 0 || (cacheLines & (cacheLines - 1)) != 0) {
      throw ArgumentError('cacheLines must be a positive power of 2');
    }

    // Create internal signals from external Logic parameters
    final internalClk = addInput('clk', clk);
    final internalReset = addInput('reset', reset);

    // Create internal interfaces by cloning external ones and connecting them
    // This follows the proper ROHD interface pattern from APB, AXI4, etc.
    upstreamReq = upstreamReqInterface.clone()
      ..connectIO(this, upstreamReqInterface,
          inputTags: {CacheControllerDirection.request},
          uniquify: (original) => 'upstream_req_$original');

    upstreamResp = upstreamRespInterface.clone()
      ..connectIO(this, upstreamRespInterface,
          outputTags: {CacheControllerDirection.response},
          uniquify: (original) => 'upstream_resp_$original');

    downstreamReq = downstreamReqInterface.clone()
      ..connectIO(this, downstreamReqInterface,
          outputTags: {CacheControllerDirection.request},
          uniquify: (original) => 'downstream_req_$original');

    downstreamResp = downstreamRespInterface.clone()
      ..connectIO(this, downstreamRespInterface,
          inputTags: {CacheControllerDirection.response},
          uniquify: (original) => 'downstream_resp_$original');

    _buildLogic(internalClk, internalReset);
  }

  /// Builds the internal logic for the cache controller.
  void _buildLogic(Logic clk, Logic reset) {
    // Get dimensions from interfaces
    final idWidth = upstreamReq.idWidth;
    final addrWidth = upstreamReq.addrWidth;

    // Create FIFO for response buffering
    final fifoWriteData =
        Logic(name: 'fifo_write_data', width: idWidth + addrWidth + dataWidth);
    final fifoWriteEnable = Logic(name: 'fifo_write_enable');
    final fifoReadEnable = Logic(name: 'fifo_read_enable');

    responseFifo = Fifo(clk, reset,
        writeEnable: fifoWriteEnable,
        writeData: fifoWriteData,
        readEnable: fifoReadEnable,
        depth: 8,
        name: 'response_fifo');

    // Put our `MultiPortedReadCache` in parallel with this inline cache code.
    final fill = ValidDataPortInterface(dataWidth, addrWidth);
    final read = ValidDataPortInterface(dataWidth, addrWidth);

    MultiPortedReadCache(clk, reset, [fill], [read], lines: cacheLines);

// Hack: we do not support simultaneous read and write today due to a bug in the
// cache.
    // fill.valid <= downstreamResp.valid;
    fill.valid <= downstreamResp.valid & ~upstreamReq.valid;
    fill.addr <= downstreamResp.addr;
    fill.en <= downstreamResp.valid;
    fill.data <= downstreamResp.data;
    read.addr <= upstreamReq.addr;
    read.en <= upstreamReq.valid;

    // Always ready to accept requests (simplified)
    upstreamReq.ready <= Const(1);

    // Response logic
    final responseFromCache = read.valid & upstreamReq.valid;
    final responseFromFifo = ~responseFifo.empty & upstreamResp.ready;

    // Connect upstream response
    upstreamResp.valid <= responseFromCache | responseFromFifo;
    upstreamResp.id <=
        mux(
            responseFromCache,
            upstreamReq.id,
            responseFifo.readData.slice(
                idWidth + addrWidth + dataWidth - 1, addrWidth + dataWidth));
    upstreamResp.addr <=
        mux(responseFromCache, upstreamReq.addr,
            responseFifo.readData.slice(addrWidth + dataWidth - 1, dataWidth));
    upstreamResp.data <=
        mux(responseFromCache, read.data,
            responseFifo.readData.slice(dataWidth - 1, 0));

    // Forward cache misses to downstream
    final cacheMiss = ~read.valid & upstreamReq.valid;

    // Ensure downstream request is always driven (avoid 'x' values)
    downstreamReq.valid <= mux(reset, Const(0), cacheMiss);
    downstreamReq.id <= mux(reset, Const(0, width: idWidth), upstreamReq.id);
    downstreamReq.addr <=
        mux(reset, Const(0, width: addrWidth), upstreamReq.addr);

    // Always ready for downstream responses
    downstreamResp.ready <= Const(1);

    // Queue downstream responses in FIFO and update cache
    fifoWriteEnable <= downstreamResp.valid;
    fifoWriteData <=
        [downstreamResp.id, downstreamResp.addr, downstreamResp.data].swizzle();

    // FIFO read control
    fifoReadEnable <= responseFromFifo;
  }
}
